#include <iostream>
#include "E101.h"
#include <math.h>

using namespace std;
class Robot{ // declarations
private:
    int v_left, v_right, cam_tilt;
    int dv;
    double line_error;
    long elapsed;
    int quadrant;
    const int cam_width = 320;
    const int cam_height = 240;
    const int v_left_go = 52;
    const int v_right_go = 44; //48
    const int left_motor = 5;
    const int right_motor = 1;
    double kp = 0.05;
    double kd = 0;
    int black;
    int line_present = 0;
    

public:
    Robot Rob(); // default constructor
    int InitHardware();
    //void ReadSetMotors();
    void SetMotors();
    int MeasureLine();
    int FollowLine();
    int measureTime();
};

int Robot::InitHardware(){
//    int err;
//    err = init(0);
    init(0);
    open_screen_stream();
    take_picture();
    update_screen();
    
    return 0;
}

/*void Robot::ReadSetMotors(){
}*/

int Robot::measureTime(){
	struct timespec ts_start;
	struct timespec ts_end;
	clock_gettime(CLOCK_MONOTONIC, &ts_start);
	//for(int i =0;  i< 560; i++){ //code_to_time();
		//double x = sin(i);
	//}
	clock_gettime(CLOCK_MONOTONIC, &ts_end);
  
	elapsed = (ts_end.tv_sec-ts_start.tv_sec)*1000000000 + ts_end.tv_nsec-ts_start.tv_nsec;
	cout<<"elapsed[ns] ="<<elapsed<<endl;
	return 0;
}
  
void Robot::SetMotors(){
    set_motors(left_motor,v_left);
    set_motors(right_motor,v_right);
    hardware_exchange();
}

int Robot::MeasureLine(){
    take_picture();
    update_screen();
    int countr = 60; //rows 1, 120, 239
	int countc = 0; //columns 
	int pixel[320]; //array list 
	int index[320];
	int error = 0;
	int max=0;
	int min =255;
	line_error=0;
	
	for(int i=0; i<=320;i++){ //setting index with negative and positive numbers
		index[i]=i-160;
	}
	
	//while(countr=80; countr<320; countr=countr+80){ //we will count three error and average it to find the final amount of error. Easiest way
		//countc=0;
		for(countc=0; countc<320; countc++){ //counting through the row 			
			int whiteVal = (int)get_pixel(countr, countc, 3);
			if (whiteVal > max) {
            max = whiteVal;
			}
			else if (whiteVal < min) {
            min = whiteVal;
			}
			int thres = (max+min)/2;
			if(whiteVal<thres){ //if black set it as 1
				pixel[countc] = 1;
				black++;
			}
			else if(whiteVal>thres){ //if white set it as 0
				pixel[countc] = 0;
			}
		}
		
		for(int n=0; n<=320; n++){//going through both arrays and comparing
			line_error = error+index[n]*pixel[n];
		}
		
		if(black>10){
			line_present=1;
		}
		else{
			line_present=0;
		}
	//}
	return 0;
}
   

int Robot::FollowLine(){
    MeasureLine();
    if (line_present==1) {
        dv = (int) (line_error*kp)+kd;
        // dv = 0;
        v_left = v_left_go + dv;
        v_right = v_right_go+dv;
        //cout << "Line error =" << line_error << " dv= " << dv;
        SetMotors();
    } else { // go back
        cout << " Line missing " <<endl;
        v_left = 44;
        v_right = 52;
        SetMotors();
        sleep1(100);
    }
    return 0;
}

int main() {
    Robot robot;
    char ip[15] = {"130.195.6.196"};
    char msg[24] = {"Please"};
    char pass[24];
    connect_to_server(ip, 1024);
    sleep1(100);
    send_to_server(msg);
    sleep1(100);
    receive_from_server(pass);
    sleep1(100);
    send_to_server(pass);
    sleep1(100);
    
    robot.InitHardware();
    while (true) {
        robot.MeasureLine();
        robot.FollowLine();
    }
    return 0;
}

